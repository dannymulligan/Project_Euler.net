#!/usr/bin/python
#
# Project Euler.net Problem 101
# 
# If we are presented with the first k terms of a sequence it is
# impossible to say with certainty the value of the next term, as
# there are infinitely many polynomial functions that can model the
# sequence.
# 
# As an example, let us consider the sequence of cube numbers. This is
#  defined by the generating function,
#
#     u(n) = n^3: 1, 8, 27, 64, 125, 216, ...
# 
# Suppose we were only given the first two terms of this
# sequence. Working on the principle that "simple is best" we should
# assume a linear relationship and predict the next term to be 15
# (common difference 7). Even if we were presented with the first
# three terms, by the same principle of simplicity, a quadratic
# relationship should be assumed.
# 
# We shall define OP(k, n) to be the n^(th) term of the optimum
# polynomial generating function for the first k terms of a
# sequence. It should be clear that OP(k, n) will accurately generate
# the terms of the sequence for n <= k, and potentially the first
# incorrect term (FIT) will be OP(k, k+1); in which case we shall call
# it a bad OP (BOP).
# 
# As a basis, if we were only given the first term of sequence, it
# would be most sensible to assume constancy; that is, for n >= 2,
# OP(1, n) = u(1).

# 
# Hence we obtain the following OPs for the cubic sequence:
#     OP(1, n) = 1               1, 1, 1, 1, ...
#     OP(2, n) = 7n-6            1, 8, 15, ...
#     OP(3, n) = 6n^2-11n+6      1, 8, 27, 58, ...
#     OP(4, n) = n^3             1, 8, 27, 64, 125, ...
# 
# Clearly no BOPs exist for k >= 4.
# 
# By considering the sum of FITs generated by the BOPs (indicated in
# red above), we obtain 1 + 15 + 58 = 74.
# 
# Consider the following tenth degree polynomial generating function:
# 
#     u(n) = 1 - n + n^2 - n^3 + n^4 - n^5 + n^6 - n^7 + n^8 - n^9 + n^10
# 
# Find the sum of FITs for the BOPs.
#
# Answer: 37076114526
# Solved: 11/10/09
# 102 problems solved
# Position #1180 on level 3

def u(n):
    return 1 - n + n**2 - n**3 + n**4 - n**5 + n**6 - n**7 + n**8 - n**9 + n**10
#def u(n):
#    return n**3

def solve(deg):
    # Create a matrix of equations of the form
    #     a*x^0 + b*x^1 + c*x^2 + ... = u(x)
    # with x = 1, 2, 3, ...
    # or
    #     a*1 + b*1 + c*1 + ... = u(1)
    #     a*1 + b*2 + c*4 + ... = u(2)
    #     a*1 + b*3 + c*9 + ... = u(3)
    #     etc...
    eqns = []
    for x in range(1,deg+1):
        eqn = []
        for t in range(0,deg):
            eqn.append(x**t)
        eqn.append(u(x))
        eqns.append(eqn)

    # Solve this equation matrix
    # Subtract top lines from lower lines
    for x in range(deg):
        for y in range(x+1,deg):
            m = eqns[y][x]/eqns[x][x]
            for z in range(deg+1):
                eqns[y][z] -= eqns[x][z]*m

    # Subtract bottom lines from upper lines
    for x in range(deg-1,-1,-1):
        d = eqns[x][x]
        eqns[x][x] /= d
        eqns[x][deg] /= d
        for y in range(x-1,-1,-1):
            m = eqns[y][x]/eqns[x][x]
            for z in range(deg+1):
                eqns[y][z] -= eqns[x][z]*m
    print "OP({0},n) =".format(deg),
    started = False
    for x in range(deg-1,-1,-1):
        if   (eqns[x][deg] > 0):
            if (not started):  print "{0}n^{1}".format(eqns[x][deg], x),
            else:              print "+ {0}n^{1}".format(eqns[x][deg], x),
            started = True
        elif (eqns[x][deg] == 0):
            continue
        elif (eqns[x][deg] < 0):
            print "- {0}n^{1}".format(-1*eqns[x][deg], x),
            started = True

    print "    ",
    BOP = 0
    for x in range(deg):
        BOP += ((deg+1)**x) * eqns[x][deg]
    print BOP
    return BOP

answer = 0
for i in range(1,11):
    answer += solve(i)
print "Answer =", answer
