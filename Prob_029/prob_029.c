// Project Euler.net Problem 29
//
// Consider all integer combinations of a^b for 2 <= a <= 5 and 2 <= b <= 5:
//
//     2^2 =  4, 2^3 =   8, 2^4 =  16, 2^5 =   32
//     3^2 =  9, 3^3 =  27, 3^4 =  81, 3^5 =  243
//     4^2 = 16, 4^3 =  64, 4^4 = 256, 4^5 = 1024
//     5^2 = 25, 5^3 = 125, 5^4 = 625, 5^5 = 3125
//
// If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:
//
//     4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
//
// How many distinct terms are in the sequence generated by a^b for 2 <= a <= 100 and 2 <= b <= 100?
//
// $Revision

#include <stdio.h>
#include <math.h>

#define MAX_A 100  // Max value of a in the a^b table
#define MAX_B 100  // Max value of b in the a^b table
#define RES    35  // Resolution of each entry in groups of 6 digits
// MAX_A = MAX_B = 100 means biggest number is 100^100 = 10^200 = 200 digits = 34 six digit groups

int main()
{
    int i, j, k, r;
    int x, y;
    int dup, zero;
    long res[MAX_A+1][MAX_B+1][RES];
    // res[i][j] will contain i^j

    // Check that we have enough room for the max value
    printf("// Check that we have enough room for the max value\n");
    printf("MAX_A = %d, MAX_B = %d, RES = %d, log10(MAX_A)*MAX_B = %g, RES needs to be >= %g\n", MAX_A, MAX_B, RES, log10(MAX_A)*MAX_B, log10(MAX_A)*MAX_B/6);
    if ((log10(MAX_A) * MAX_B) > (6*RES)) {
        printf("Error: RES not big enough\n");
        return(1);
    }

    // Initialize the result table
    printf("// Initialize the result table\n");
    for (i = 2; i <= MAX_A; i++) {
        for (j = 2; j <= MAX_B; j++) {
            res[i][j][0] = 1;
            for (k = 1; k < RES; k++) {
                res[i][j][k] = 0;
            }
        }
    }

    // Calculate the result table
    printf("// Calculate the result table\n");
    for (i = 2; i <= MAX_A; i++) {
        for (j = 2; j <= MAX_B; j++) {
            for (k = 1; k <= j; k++) {
                // Multiply RES digits
                for (r = 0; r < RES; r++) {
                    res[i][j][r] = res[i][j][r] * i;
                }

                // Fix up any overflows
                long temp;
                for (r = 0; r < RES; r++) {
                    if (res[i][j][r] >= 1000000) {
                        temp           = res[i][j][r] / 1000000;
                        res[i][j][r]   = res[i][j][r] - temp*1000000;
                        res[i][j][r+1] = res[i][j][r+1] + temp;
                    }
                }
            }
        }
    }

//    // Print the result table
//    printf("// Print the result table\n");
//    for (i = 2; i <= MAX_A; i++) {
//        for (j = 2; j <= MAX_B; j++) {
//            printf("%3d^%-3d =", i, j);
//
//            zero = 1;
//            for (r = RES-1; r >= 0; r--)
//                if (res[i][j][r] != 0)  zero = 0;
//
//            if (zero)
//                for (r = RES-1; r >= 0; r--) {
//                    printf(" ------");
//                }
//            else
//                for (r = RES-1; r >= 0; r--) {
//                    printf(" %06d", res[i][j][r]);
//                }
//            printf(", \n");
//        }
//        //printf("\n");
//    }

    // Look for repeats in the results table
    printf("// Look for repeats in the result table\n");
    int tot_dups = 0;
    for (i = 2; i <= MAX_A; i++) {
        for (j = 2; j <= MAX_B; j++) {
            // Check the rest of the table for duplicates
            for (x = 2; x <= MAX_A; x++) {
                for (y = 2; y <= MAX_B; y++) {
                    if ((i != x) && (j != y)) { // Don't compare an item with itself
                        dup = 1; zero = 1;
                        for (r = 0; r < RES; r++) {
                            if (res[x][y][r] != res[i][j][r])  dup = 0;
                            if (res[x][y][r] != 0)             zero = 0;
                        }
                        if (!zero && dup) {
                            for (r = 0; r < RES; r++) {
                                res[x][y][r] = 0;
                            }
                            tot_dups++;
                        }
                    }
                }
            }
        }
    }
    printf("Found %d duplicates\n", tot_dups);

//    // Print the result table
//    printf("// Print the result table\n");
//    for (i = 2; i <= MAX_A; i++) {
//        for (j = 2; j <= MAX_B; j++) {
//            printf("%3d^%-3d =", i, j);
//
//            zero = 1;
//            for (r = RES-1; r >= 0; r--)
//                if (res[i][j][r] != 0)  zero = 0;
//
//            if (zero)
//                for (r = RES-1; r >= 0; r--) {
//                    printf(" ------");
//                }
//            else
//                for (r = RES-1; r >= 0; r--) {
//                    printf(" %06d", res[i][j][r]);
//                }
//            printf(", \n");
//        }
//        //printf("\n");
//    }
//
    // Count the results in the result table
    printf("// Count the results in the result table\n");
    int answer = 0;
    dup = 0;
    for (i = 2; i <= MAX_A; i++) {
        for (j = 2; j <= MAX_B; j++) {
            zero = 1;
            for (r = 0; r < RES; r++) {
                if (res[i][j][r] != 0)  zero = 0;
            }
            if (zero)  dup++;
            else       answer++;
        }
    }

    // Print the answer
    printf("// Print the answer\n");
    printf("Found %d non-zero entries and %d duplicates in the result table\n", answer, dup);

}
